<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us" xml:lang="en-us">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<meta name="copyright" content="(C) Copyright 2005" />
<meta name="DC.rights.owner" content="(C) Copyright 2005" />
<meta content="reference" name="DC.Type" />
<meta name="DC.Title" content="Component Report" />
<meta name="abstract" content="Analyze a component for possible memory waste and other inefficiencies." />
<meta name="description" content="Analyze a component for possible memory waste and other inefficiencies." />
<meta content="XHTML" name="DC.Format" />
<meta content="ref_inspections_component_report" name="DC.Identifier" />
<meta content="en-us" name="DC.Language" />
<link href="..\..\styles/commonltr.css" type="text/css" rel="stylesheet" />
<title>Component Report</title>
</head>
<body id="ref_inspections_component_report"><a name="ref_inspections_component_report"><!-- --></a>


	<h1 class="topictitle1">Component Report</h1>

	
	<div><p>Analyze a component for possible memory waste and
		other inefficiencies.</p>

		<div class="section" id="ref_inspections_component_report__introduction"><a name="ref_inspections_component_report__introduction"><!-- --></a><h2 class="sectiontitle">Introduction</h2>
			
			<p>A heap dump contains millions of objects. But which of those
				belong to your component? And what conclusions can you draw from
				them? This is where the Component Report can help.</p>

			<p>
				Before starting, one has to decide what constitutes a component.
				Typically, a component is either a set of classes in a
				<strong>common root package</strong>
				or a set of classes loaded by the same
				<strong>class loader</strong>
				.
			</p>

			<p>
				Using this root set of objects, the component report calculates a
				customized retained set. This retained set includes all objects kept
				alive by the root set. Additionally, it assumes that all objects
				that have become
				<em>finalizable</em>
				actually have been finalized and that also all soft references have
				been cleared.
			</p>

		</div>

		<div class="section" id="ref_inspections_component_report__run"><a name="ref_inspections_component_report__run"><!-- --></a><h2 class="sectiontitle">Executing the Component Report</h2>
			
			<p> To run the report for a common root package, select the component
				report from the tool bar and provide a regular expression to match
				the package:</p>

			<img src="component_report_package.png" alt="Regular expression to match common root package to be&#13;&#10;&#9;&#9;&#9;&#9;&#9;used for the component report." />
			<p> Alternatively, one can group the class histogram by class loader
				and then right-click the appropriate class loader and select the
				component report:</p>

			<img src="component_report_classloader.png" alt="Group histogram by class loader." />
		</div>

		<div class="section" id="ref_inspections_component_report__overview"><a name="ref_inspections_component_report__overview"><!-- --></a><h2 class="sectiontitle">Overview</h2>
			
			<p>The component report is rendered as HTML. It is stored in a ZIP
				file next to the heap dump file.</p>

			<img src="component_report_overview.png" alt="Overview section of the component report." />
			<div class="p">
				<br /><ol class="arrows">
					<li>Details about the size, the number of classes, the
						number of objects and the number of different class loaders.</li>

					<li>The pie chart shows the size of the component relative to
						the total heap size.</li>

					<li>
						The
						<a href="top_consumers.html">Top Consumers</a>
						section lists the biggest object, classes, class loader and
						packages which are retained by the component. It provides a good
						overview of what is actually kept alive by the component.
					</li>

					<li>
						<a href="retained_set.html">Retained Set
						</a>
						displays all objects grouped by classes which are retained.
					</li>

				</ol>

			</div>

		</div>

		<div class="section" id="ref_inspections_component_report__strings"><a name="ref_inspections_component_report__strings"><!-- --></a><h2 class="sectiontitle">Duplicate Strings</h2>
			
			<p>
				Duplicate Strings are a prime example for memory waste: multiple
				char arrays with identical content. To find the duplicates, the
				report
				<a href="group_by_value.html">groups</a>
				the char arrays by their value. It lists all char arrays with 10 or
				more instances with identical content.
			</p>

			<div class="p">
				The content of the char arrays typically gives away ideas how to
				reduce the duplicates:
				<br /><ul>
					<li>
						Sometimes the duplicate strings are used as
						<strong>keys or values in hash maps</strong>
						. For example, when reading heap dumps, MAT itself used to read
						the char constant denoting the type of an attribute into memory.
						It turned out that the heap was littered with many 'L's for
						references, 'B's for bytes, and 'Z's for booleans, etc. By
						replacing the
						<samp class="codeph">char</samp>
						with an
						<samp class="codeph">int</samp>
						, MAT could save some of the precious memory. Alternatively,
						Enumerations could do the same trick.
					</li>

					<li>
						When reading
						<strong>XML documents</strong>
						, fragments like
						<samp class="codeph">UTF-8</samp>
						, tag names or tag content remains in memory. Again, think about
						using Enumerations for the repetitive content.
					</li>

					<li>
						Another option is
						<a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html#intern()">interning</a>
						the String. This adds the string to a pool of strings which is
						maintained privately by the class
						<samp class="codeph">String</samp>
						. For each unique string, the pool will keep on instance alive.
						However, if you are interning, make sure do it
						<strong>responsibly</strong>
						: A big pool of strings will have maintenance costs and one cannot
						rely on interned strings being garbage collected.
					</li>

				</ul>

			</div>

		</div>

		<div class="section" id="ref_inspections_component_report__emptycol"><a name="ref_inspections_component_report__emptycol"><!-- --></a><h2 class="sectiontitle">Empty Collections</h2>
			
			<p>Even if collections are empty, they usually consume memory
				through their internal object array. Imagine a tree structure where
				every node eagerly creates array lists to hold its children, but
				only a few nodes actually possess children.</p>

			<p>
				One remedy is the lazy initialization of the collections: create the
				collection only when it is actually needed. To find out who is
				responsible for the empty collections, use the
				<a href="immediate_dominators.html" title="Find out who is keeping alive a set of objects.">immediate
					dominators</a>
				command.
			</p>

		</div>

		<div class="section" id="ref_inspections_component_report__colfillratio"><a name="ref_inspections_component_report__colfillratio"><!-- --></a><h2 class="sectiontitle">Collection Fill Ratio</h2>
			
			<p>Just like empty ones, collections with only a few elements
				also take up a lot of memory. Again, the backing array of the
				collection is the main culprit. The examination of the fill ratios
				using a heap dump from a production system gives hints to what
				initial capacity to use.</p>

		</div>

		<div class="section" id="ref_inspections_component_report__softref"><a name="ref_inspections_component_report__softref"><!-- --></a><h2 class="sectiontitle">Soft Reference Statistics</h2>
			
			<div class="p">
				Soft references are cleared by the virtual machine in response to
				memory demand. Usually, soft references are used to implement
				caches: keep the objects around while there is sufficient memory,
				clear the objects if free memory becomes low.
				<br /><ul>
					<li>Usually objects are cached, because they are expensive
						to re-create. Across a whole application, soft referenced objects
						might carry very different costs. However, the virtual machine
						cannot know this and clears the objects on some least recently
						used algorithm. From the outside, this is very unpredictable and
						difficult to fine tune.</li>

					<li>
						Furthermore, soft references can impose a
						<em>stop-the-world</em>
						phase during garbage collection. Oversimplified, the GC marks the
						object graph behind the soft references while the virtual machine
						is stopped.
					</li>

				</ul>

			</div>

		</div>

		<div class="section" id="ref_inspections_component_report__finalizer"><a name="ref_inspections_component_report__finalizer"><!-- --></a><h2 class="sectiontitle">Finalizer Statistics</h2>
			
			<div class="p">
				Objects which implement the
				<samp class="codeph">finalize</samp>
				method are included in the component report, because those objects
				can have serious implications for the memory of a Java Virtual
				Machine:
				<br /><ul>
					<li>
						Whenever an object with finalizer is created, a corresponding
						<samp class="codeph">java.lang.ref.Finalizer</samp>
						object is created. If the object is only reachable via its
						finalizer, it is placed in the queue of the finalizer thread and
						processed. Only then the next garbage collection will actually
						free the memory. Therefore it takes at least two garbage
						collections until the memory is freed.
					</li>

					<li>When using Sun's current virtual machine implementation,
						the finalizer thread is a single thread processing the finalizer
						objects sequentially. One blocking finalizer queue therefore can
						easily keep alive big chunks of memory (all those other objects
						ready to be finalized).</li>

					<li>
						Depending on the actual algorithm, finalizer may require a
						<em>stop-the-world</em>
						pause during garbage collections. This, of course, can have
						serious implications for the responsiveness of the whole
						application.
					</li>

					<li>Last not least, the time of execution of the finalizer is
						up to the VM and therefore unpredictable.</li>

				</ul>

			</div>

		</div>

		<div class="section" id="ref_inspections_component_report__mapcollision"><a name="ref_inspections_component_report__mapcollision"><!-- --></a><h2 class="sectiontitle">Map Collision Ratios</h2>
			
			<p>This sections analyzes the collision ratios of hash maps. Maps
				place the values in different buckets based on the hash code of the
				keys. If the hash code points to the same bucket, the elements
				inside the bucket are typically compared linearly.</p>

			<p>High collision ratios can indicate sub-optimal hash codes.
				This is not a memory problem (a better hash code does not save
				space) but rather performance problem because of the linear access
				inside the buckets.</p>

		</div>

	</div>


</body>
</html>