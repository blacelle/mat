options
{
	IGNORE_CASE=true ;
	STATIC=false;
//	DEBUG_LOOKAHEAD=true;
	JAVA_UNICODE_ESCAPE=false;
}

PARSER_BEGIN(OQLParser)
package org.eclipse.mat.parser.internal.oql.parser;

import java.math.BigInteger;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;

import org.eclipse.mat.internal.snapshot.oql.ICompiler;
import org.eclipse.mat.internal.snapshot.oql.compiler.Attribute;
import org.eclipse.mat.internal.snapshot.oql.compiler.Query;
import org.eclipse.mat.internal.snapshot.oql.compiler.Expression;

public class OQLParser
{
	ICompiler compiler;
	
	public void setCompiler(ICompiler compiler)
	{
		this.compiler = compiler;
	}

//	public static void main( String args[] ) throws ParseException//	{//        System.out.println("Reading from stdin");//        OQLParser p = new OQLParser(System.in);//        p.setCompiler(new org.eclipse.mat.internal.snapshot.oql.compiler.CompilerImpl());//        Query q = p.ParseQueryFromInputLine();//        System.out.println(q);//        //        System.out.println("Parse Successfull") ;//    }
}

PARSER_END(OQLParser)

/* WHITE SPACE */

SKIP:
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT/* RESERVED WORDS AND LITERALS */
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN:
{
	<K_AS : "AS">
|	<K_AS_RETAINED_SET : "AS RETAINED SET">
|	<K_CALL : "CALL">
|	<K_DISTINCT : "DISTINCT">
|   <K_IN : "IN">
|   <K_INSTANCEOF : "INSTANCEOF">
|   <K_IS : "IS">
|   <K_LIKE : "LIKE">
|   <K_NOT : "NOT">
|   <K_OBJECTS : "OBJECTS">
|   <K_FROM : "FROM">
|   <K_SELECT : "SELECT">
|   <K_UNION : "UNION">
|   <K_WHERE : "WHERE">
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < LONG_LITERAL:
        <DECIMAL_LITERAL> ["l","L"]
      | <OCTAL_LITERAL> ["l","L"]
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  <HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   ~["'","\\","\n","\r"]
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   ~["\"","\n","\r"]
      )*
      "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
    <TRUE: "true">
|   <FALSE: "false">
|   <OR: "or">
|   <AND: "and">
|   <NULL: "null">
|   <IMPLEMENTS: "implements">
|	<DOLLAR_SIGN: "$">		
|   <IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|<DOLLAR_SIGN>)* >
|
    < #LETTER:
      [
       "\u0041"-"\u005a",       "\u005f",       "\u0061"-"\u007a",       "\u00c0"-"\u00d6",       "\u00d8"-"\u00f6",       "\u00f8"-"\u00ff",       "\u0100"-"\u1fff",       "\u3040"-"\u318f",       "\u3300"-"\u337f",       "\u3400"-"\u3d2d",       "\u4e00"-"\u9fff",       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",       "\u0660"-"\u0669",       "\u06f0"-"\u06f9",       "\u0966"-"\u096f",       "\u09e6"-"\u09ef",       "\u0a66"-"\u0a6f",       "\u0ae6"-"\u0aef",       "\u0b66"-"\u0b6f",       "\u0be7"-"\u0bef",       "\u0c66"-"\u0c6f",       "\u0ce6"-"\u0cef",       "\u0d66"-"\u0d6f",       "\u0e50"-"\u0e59",       "\u0ed0"-"\u0ed9",       "\u1040"-"\u1049"
      ]
  >
}

/* OPERATORS */

TOKEN :
{
  < LT: "<" >
| < BANG: "!" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
}

/*******************************
 * THE OQL GRAMMAR STARTS HERE *
 *******************************/

Query ParseQuery():
{ Query q; }
{
    q = SelectStatement() <EOF>
    {
    	return q;
    }
}

Query ParseQueryFromInputLine():
{ Query q; }
{
    q = SelectStatement() ";"
    {
    	return q;
    }
}


Query SelectStatement():
{
 	Query q = new Query();
}
{
     "SELECT" SelectList(q)
    FromClause(q)
    [ WhereClause(q) ]
    [ UnionClause(q) ]
    {
    	return q;
    }
}


/* ---------------- select --------------------- */

void SelectList(Query q):
{
	Query.SelectClause selectClause = new Query.SelectClause();
	List<Query.SelectItem> columns = new ArrayList<Query.SelectItem>();
	Query.SelectItem a;
}
{
	(
	    [
	    	"DISTINCT" { selectClause.setDistinct(true); }
		    |
		    "AS RETAINED SET" { selectClause.setRetainedSet(true); }
		]
	    (
	    	"*"
	    	|
	    	"OBJECTS" a = SelectItem() { columns.add(a); selectClause.setAsObjects(true); }
		    |
		    a = SelectItem() { columns.add(a); }
			(
				"," a = SelectItem() { columns.add(a); }
			)*
		)
	)
    {
    	selectClause.setSelectList(columns);
    	q.setSelectClause(selectClause);
    }
}

Query.SelectItem SelectItem():
{
	Object ex = null;
	Token t1 = null, t2 = null;
}
{
	( ex = PathExpression() | ex = EnvVarPathExpression() ) [ "AS" ( t1 = <STRING_LITERAL> | t2 = <IDENTIFIER> ) ]
	{
		String name = null;
		if (t1 != null)
			name = t1.image.substring(1, t1.image.length() - 1);
		else if (t2 != null)
			name = t2.image;

		return new Query.SelectItem(name, (Expression)ex);
	}
}

Object PathExpression():
{
	List<Object> elements = new ArrayList<Object>();
	Object ex = null;
}
{
	(
		ex = ObjectFacet(true) { elements.add(ex); }
	)
	(
		"." ex = ObjectFacet(false) { elements.add(ex); }
	)*
	{
		return compiler.path(elements);
	}
}

Object EnvVarPathExpression():
{
	LinkedList<Object> elements = new LinkedList<Object>();
	Object ex = null;
	Token t_name = null;
}
{
	(
		"$" t_name = <IDENTIFIER>
	)
	(
		"." ex = ObjectFacet(false) { elements.add(ex); }
	)*
	{
		elements.addFirst(new Attribute(t_name.image, false, true));
		return compiler.path(elements);
	}
}

Object ObjectFacet(boolean isFirstInPath):
{
	Token t_native = null, t_name = null;
	List<Expression> parameters = null;
	Object ex = null;
}
{
	(
		[ t_native = "@"]
		t_name = <IDENTIFIER>
		[ parameters = ParameterList() ]
		{
			if (parameters != null)
				ex = compiler.method(t_name.image, parameters, isFirstInPath);
			else
				ex = new Attribute(t_name.image, t_native != null, false);
		}
	)
	{
		return ex;
	}
}


List<Expression> ParameterList():
{
	List<Expression> parameters = new ArrayList<Expression>();
	Object expr = null;
}
{
	"("
	[
	(
		expr = SimpleExpression() { parameters.add((Expression)expr); }
		(
			"," expr = SimpleExpression() { parameters.add((Expression)expr); }
		)*
	)
	]
	")"
	{
		return parameters;
	}
}


/* ---------------- from --------------------- */

void FromClause(Query q):
{
	Query.FromClause fromItem = new Query.FromClause();
	Query subSelect = null;
	
	Token t1 = null, t2 = null, t3 = null;
}
{
    "FROM"
	[ t1 = "OBJECTS" ]
	[ t2 = "INSTANCEOF" ]
    ( FromItem(fromItem) | "(" subSelect = SelectStatement() ")" )
	[ t3 = <IDENTIFIER> ]
    {
    	fromItem.setSubSelect(subSelect);
    	
    	fromItem.setIncludeObjects( t1 != null );
 		fromItem.setIncludeSubClasses( t2 != null );
 		
		if (t3 != null) fromItem.setAlias(t3.image);
		
    	q.setFromClause(fromItem);
    }
}

void FromItem(Query.FromClause fromClause):
{
	Token t = null;
	Object expr = null;
	String className = null;
	long address = 0;
	int objectId = 0;
}
{
	(
		className = ClassName() { fromClause.setClassName( className ); }
	|	t = <STRING_LITERAL> { fromClause.setClassNamePattern(t.image.substring(1, t.image.length() - 1)); }
	|	address = ObjectAddress() { fromClause.addObjectAddress(address); } ( "," address = ObjectAddress() { fromClause.addObjectAddress(address); } )*
	|	objectId = ObjectId() { fromClause.addObjectId(objectId); } ( "," objectId = ObjectId() { fromClause.addObjectId(objectId); } )*
	|	expr = EnvVarPathExpression() { fromClause.setCall((Expression)expr); }
	)
}

String ClassName():
{ StringBuilder b = new StringBuilder(); Token t; }
{
	(
	    t = <IDENTIFIER> { b.append(t.image); }
	    ( "." t = <IDENTIFIER> { b.append(".").append(t.image); } )*
	  	( "[]" { b.append("[]"); } )*
	)
	{
		return b.toString();
	}
}

long ObjectAddress():
{
	Token t = null;
}
{
	t = <HEX_LITERAL>
	{
		return new BigInteger(t.image.substring(2), 16).longValue();
	}
}

int ObjectId():
{
	Token t = null;
}
{
	t = <INTEGER_LITERAL>
	{
		return Integer.parseInt(t.image);
	}
}


/* ---------------- where --------------------- */

void WhereClause(Query q):
{ Object ex; }
{
    "WHERE" ex = ConditionalOrExpression()
    {
    	q.setWhereClause((Expression)ex);
  	}
}

Object ConditionalOrExpression():
{ Object ex, r; ArrayList<Object> list = null; }
{
	ex = ConditionalAndExpression() (
  			"or" r = ConditionalAndExpression()
			{
				if (list == null)
				{
					list = new ArrayList<Object>();
					list.add(ex);
                }
				list.add(r);
            }
	)*
	{
        if (list != null)
        {
            ex = compiler.or(list.toArray());
        }
        return ex;
    }
}

Object ConditionalAndExpression():
{ Object ex, r; ArrayList<Object> list = null; }
{
	ex = EqualityExpression() (
  			"and" r = EqualityExpression()
			{
				if (list == null)
				{
					list = new ArrayList<Object>();
					list.add(ex);
                }
				list.add(r);
            }
	)*
	{
        if (list != null)
        {
            ex = compiler.and(list.toArray());
        }
        return ex;
    }
}

Object EqualityExpression():
{ Object ex, r; }
{
	ex = RelationalExpression() ((
  		  "=" r = RelationalExpression() { ex = compiler.equal(ex, r); }
  		| "!=" r = RelationalExpression() { ex = compiler.notEqual(ex, r); }
	))*
	{
		return ex;
	}
}

Object RelationalExpression():
{Object ex, r;}
{
	(
		ex = SimpleExpression() ((
			  "<"  r = SimpleExpression() { ex = compiler.lessThan(ex, r); }
			| ">"  r = SimpleExpression() { ex = compiler.greaterThan(ex, r); }
			| "<=" r = SimpleExpression() { ex = compiler.lessThanOrEqual(ex, r); }
			| ">=" r = SimpleExpression() { ex = compiler.greaterThanOrEqual(ex, r); }
			| ( LOOKAHEAD(2) ex = LikeClause(ex) | ex = InClause(ex) )
			| "implements" r = ClassName() { ex = compiler.instanceOf(ex, (String)r); }
	  	))?
	)
	{
		return ex;
	}
}

Object LikeClause(Object left):
{
	Token t1 = null, t2 = null;
}
{
  	[ t1 = <K_NOT> ] <K_LIKE> t2 = <STRING_LITERAL>
	{
		String pattern = t2.image.substring(1, t2.image.length() - 1);
		return t1 == null ? compiler.like(left, pattern) : compiler.notLike(left, pattern);
	}
}


Object InClause(Object left):
{
	Object r;
	Token t = null;
}
{
  	[ t = <K_NOT> ] <K_IN> r = SimpleExpression()
	{
		return t == null ? compiler.in(left, r) : compiler.notIn(left, r);
	}
}

Object SimpleExpression():
{ Object ex, r; }
{
	ex = MultiplicativeExpression() ((
  		  "+" r = MultiplicativeExpression() { ex = compiler.plus(ex, r); }
  		| "-" r = MultiplicativeExpression() { ex = compiler.minus(ex, r); }
	))*
	{
		return ex;
	}
}


Object MultiplicativeExpression():
{ Object ex, r; }
{
	ex = PrimaryExpression() ((
  		  "*" r = PrimaryExpression() { ex = compiler.multiply(ex, r); }
  		| "/" r = PrimaryExpression() { ex = compiler.divide(ex, r); }
	))*
	{
		return ex;
	}
}

Object PrimaryExpression():
{ Object ex; }
{
	ex = Literal()
	{
		return ex;
	}
	|
	"(" ( ex = ConditionalOrExpression() | ex = SubQuery() ) ")"
	{
		return ex;
	}
	|
	ex = PathExpression()
	{
		return ex;
	}
	|
	ex = EnvVarPathExpression()
	{
		return ex;
	}
}

Object SubQuery():
{ Query q; }
{
	q = SelectStatement()
	{
		return compiler.subQuery(q);	
	}
}

Object Literal():
{ Object ex; Token t; }
{
	(
		ex = NumberLiteral()
	|
		t = <CHARACTER_LITERAL>
		{
			ex = compiler.literal(Character.valueOf(t.image.charAt(1)));
		}
	|
		t = <STRING_LITERAL>
		{
			ex = compiler.literal(t.image.substring(1, t.image.length() - 1));
		}
	|
		ex = BooleanLiteral()
	|
		ex = NullLiteral()
	)
	{
		return ex;
	}
}

Object NumberLiteral():
{ Object ex; Token t, unary = null; }
{
	( unary = "+" | unary = "-" )?
	(
		t = <INTEGER_LITERAL>
		{
			int anInt = Integer.parseInt(t.image);
			if (unary != null && "-".equals(unary.image))
				anInt *= -1;
				
			ex = compiler.literal(anInt);
		}
	|
		t = <LONG_LITERAL>
		{
			long aLong = Long.parseLong(t.image.substring(0, t.image.length()-1));
			if (unary != null && "-".equals(unary.image))
				aLong *= -1;
			
			ex = compiler.literal(aLong);
		}
	|
		t = <FLOATING_POINT_LITERAL>
		{
			float aFloat = Float.parseFloat(t.image);
			if (unary != null && "-".equals(unary.image))
				aFloat *= -1;
			
			ex = compiler.literal(aFloat);
		}
	)
	{
		return ex;
	}
}

Object BooleanLiteral():
{}
{
	"true"
	{
		return compiler.literal(Boolean.TRUE);
	}
|
	"false"
	{
		return compiler.literal(Boolean.FALSE);
	}
}

Object NullLiteral():
{}
{
	<NULL>
	{
		return compiler.nullLiteral();
	}
}

/* ---------------- union --------------------- */

void UnionClause(Query q):
{
	Query unionQuery = null;
}
{
    ( <K_UNION> "(" unionQuery = SelectStatement() ")" { q.addUnionQuery(unionQuery); } )+
}

